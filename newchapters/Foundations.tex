\declchap{Foundations}{found}

Before describing the technologies on which the current work is based, as well as the work itself,
it makes sense to describe more general foundations and principles, around which the technology is built.

In the \rsec{dslsandides} we describe two approaches to create an \Rg{ide} for a certain language, and mainly the 
projectional approach, which originates from the area of building new \Rgp{dsl}.

In the \rsec{modularlang} we describe the modular approach towards language engineering and extending, intensively
used with the projectional approach to construct languages.

% TODO If more sections appear in this chapter - mention them here

\declsec{Building DSLs and IDEs}{dslsandides}

This section compares the traditional approach to build textual editors for the program code with
the projectional approach, bringing up  motivation for the least.

\subsection{Traditional Approach}
Traditionally programming languages are used in a textual form in text files, forming programs.
However the textual nature is not typical for the structure of programs themselves, being rather a low-level code representation, especially when talking abut syntax, which is only necessary for 
parsers to produce correct results, and not for the program intended semantics.

% About syntax trash here

Parsers are used to construct so-called \rg{ast}s from the textual 
program representation. \rg{ast}s are structures in memory, usually graph-alike, 
reminding a control flow graph, where nodes are different statements and edges are 
the ways control passes from one statement to the next one.

For the developer, using an editor, the degree to which the editor can support the development
process is important. For this, the editor has to recognize the programming language constructions and provide possible assistance. Among such assistance can be code formatting, syntax validation,
source code transformations (including refactoring support), code analyses and verification, 
source code generation and others. Many of these operation rely indeed on the higher than text level notions related to program such as a method, a variable, a statement. 
A good editor has to be aware of these higher level program structures, to provide meaningful automations for the operations mentioned above.

Nowadays, most of the editors work with text, and, to provide assistance to a programmer, integrate
with a parser/compiler front-end for the programming language. Such way to extract the program
structure during editing is not perfect for several reasons:

\begin{itemize}
 \item The program being edited as text is not syntactically correct at every moment, 
being incomplete, for example. Under such circumstances the parsing front-end can not be
successfully invoked and returns error messages which are either not related to the program, when
the code is completed, or false-positive warning and errors. 
  
 \item After a minor editing of the code, usually the whole text file has to be processed again. Such compiler calls are usually 
computationally expensive, they slow down, sometimes significantly, the performance of the developer machine. Various techniques exist to speed it up, including partial 
and pre- compilation, but the problem is still relevant to a large extent. 

\item The textual nature of the code complicates certain operations additionally. As an example, we can take a refactoring
to rename a method. Every usage of the method, being renamed, has to be found and changed. To implement it correctly an editor must take into account various possible name collisions, as well 
as presume a compilable state of the program prior to the start of the refactoring.

\end{itemize}

Not to mention the parsing problem itself. Parsing a program in a complex language like C++ is a difficult problem, it involves 
the need to resolve correctly scoping and typing, templates and related issues, work with pre-processor directives incorporated
in the code. In this regard different compilers treat C++ in a different way, creating dialects, which may represent obstacles for
the code to be purely cross-platform.

\cpp{Closing several blocks}{blocks}

The textual representation of program code, involves the need in formatting and preserving syntax. These both tasks, indeed,  have nothing to do with the functionality program, and additionally 
load the developer, reducing productivity. As an example, here we can mention the need to close
several blocks ending at the same point correctly, indenting the closing brace symmetrically 
to opening one. The \rl{blocks} demonstrates it in the last few lines.

\subsection{Projectional Approach}

Another approach a creator can take when building an \rg{ide}  is called \rg{projectionalapproach}. 
Projectional editors do not work with a low-level textual representation of a program, but rather with a higher level concept, \rg{ast}s.
This approach is especially useful and used when constructing new \rg{dsl}s.

Working with \rg{ast}s directly has several advantages over the conventional textual code editing:

\begin{itemize}
 \item All syntax errors are no longer possible, as there is no syntax. 
 \item There is no need to format the code on the level of indentation and look, since it is only
needed for textual code.
  \item All features, which in textual approach require parsing, can be implemented without a parser involved, because \rg{ast} is always known to the editor.
\end{itemize}

Additionally, as the compilers still expect a code in a textual form, code generation is used to
convert the \rg{ast} into the text code for the further use. The code generation step can be 
customized to provide support for a variety of compilers, when the compilers differ.

Projectional editors have to display the \rg{ast} to the developer, in order for him/her to work with it. Such visualization
of an \rg{ast} is called ``projection'', giving a name to the editor class.

The model of code is stored as an \rg{ast} in the projectional editor. As in the Model-View-Controller pattern the view for
the model can be implemented separately, \cite{GOF95}. Thus the code may be presented in a number of different ways to the user. For example, 
the \rg{ast} can be visualized as a graph, similar to control flow graph. This visualization, however, is not always advantageous being sometimes not compact and
complicated to overview.

\ms{constructor}{Example projection of an \rg{ast}, ``source code'' view}

One of the well-accepted way to visualize \rg{ast} is by visualizing its textual representation, as if
it would be written as a text code in the programming language, see \fig{constructor}. There can be in  
principle many such textual visualizations, supporting different ways the code looks. Normally in 
the traditional approach this has to be achieved by reformatting, and thus changing, the source code.
This is performed for the code to look similar across the developed software, and standards or coding 
guidelines are written to enforce the way to format the text code. Compare to the projectional approach,
where such formatting guidelines are not needed, when arguing about the low-level code formatting,
like indentation.

The textual projection of the \rg{ast} looks similar to the text code. However the projectional 
nature of it has certain outcomes, which may be unusual for a programmer, who is used to editing
the code as text.

The statements in the projectional editor are only selected as whole. There is now way to just select 
the ``while'' word for cut or copy, without selecting the condition and the block belonging to the statement. 
This behavior represents the position of the condition and \cc{while}-body in the \rg{ast} as children of the \cc{while} 
statement. The statement can be selected all together only, including all of its children. Alternatively, one could 
select just an expression in the condition part.

Every block delimiters are just a part of the block visualization. They are organized in a proper way
automatically, and there is no way to delete or confuse them, as well as to type them initially. Each
closing brace can marked with the parent statement name (through implementing such behavior in the
\rg{ast} visualization), enhancing navigation through the displayed code.

% As one can see, the textual projection of the \rg{ast} looks almost the same, as a text code in a 
% conventional textual editor. This can cause some confusion for the developer at first, 
% as attempts to edit this textual visualization as a real text will sometimes fail. 
% 
% Eventually, however, advantages of such visualization overwhelm the disadvantages. 

Among the benefits of the textual projection over text code are quicker code construction 
after short learning, a more structured way to select code fragments, since not individual 
characters or lines, but rather \rg{ast} nodes or groups of nodes are selected, 
plus, all the advantages, the projectional editing brings by itself, as discussed above.

we discuss additionally the projectional approach and some of its basic 
principles, which we consider to be of practical value in the \rsec{genprinciples}.

\declsec{Modular Language Engineering}{modularlang}

\subsection{Describing a Language in Projection}

When  building a projectional editor for a language, the language must be given as a certain description of a possible \Rg{ast} in the language.
As an \rg{ast} represents a graph, the nodes and edges types, as well as their possible relationships must be described\footnote{Compare this
with the textual approach, where a grammar for the language must be built, which is generally speaking complex, and some times even not a
possible task, which leads to the increasing parser complexity, known problem in particular in the C++ area}. 

The nodes of an
\rg{ast} are described through giving their types. The node type in projectional editing is called a \rg{concept}. \Rgp{concept} are very
similar to classes in object oriented programming languages. They feature inheritance, they can implement interfaces, they can have internal data, similar
to member fields, and they can feature behavior, similar to member functions. The difference with classes, however, is that the member fields are not 
usually encapsulated.

The edges of the \rg{ast} are not described on their own, but instead as a properties of nodes. A node can have children, or can reference other nodes.
An example of child relationship, can be a condition expression of the \cc{if} statement. An example of reference relationship can be a local variable usage,
referencing the declaration of the local variable. Child and reference relationships can have different cardinality, with minimal border from 0 or 1, to the 
maximal border of 1 or N, where N stands for just ``many'', or several.

The cardinality itself, is not usually enough, to restrict as desirable node relationships. Special constraints can be added and checked for 
each relationship, which describe precisely, or provide procedure to check, the validity of a relationship being established. The projectional editor
must inform the user, every time, the constraint was not satisfied, so that the user has a chance to correct the code, to match a valid \Rg{ast} description.

For the user to be able to manipulate the \rg{ast} for each node \rg{concept} an editor has to be created. The editor defines, how a node of a given \rg{concept}
should be represented to the user, which editing operations, and how, the user may perform on the node.

The minimal set of data was described above, which has to be defined for a language, to enable the projectional editing for it.

Additionally, constraints may be refined, involving some usual for typed languages type restrictions and checks. Generators can be added to 
transform \Rgp{ast} given in a language. Text generators can be defined to generate a text code from an \rg{ast}.

Behavior can be defined for a concept, to provide some method-like functionality to it. Additionally, some user-invokable functions can be described, to
perform manipulations with the \Rg{ast}.

The process of defining a modular language in the \jbmps\ environment is described additionally with practical details in the \rsec{mps}.

\subsection{Language Modularity}
\label{modularity}

As \rgp{concept} feature inheritance, it is possible\footnote{to some extent, the extensibility is described separately in one of the following chapters} 
to use a child concept at a place where a parent concept could be used. This creates a great opportunity for language extensibility. In order to 
extend a language at some point, just a passing base \rg{concept} hast to be determined and inherited from, by a new \rg{concept} which is meant
to provide the language extension. The new concept is immediately able to be used in place of the base concept. As an example, one could think 
of extending statements of the language. The only new statement is needed, a \rg{concept} has to be created, which represents the new statement, 
and enabling the new statement consist of just inheriting it from the base statement concept, which exists in the language extended, \fig{LanguageModularity}.

\gr{LanguageModularity}{An Example of Modular Language Reuse and Extension}{0.6}

The inheritance works over the language borders, allowing to create the child concept
in a language L2, separate from the language L1, where the original parent concept has been described. Thus the language L2 can be seen as a modular extension to the
language L1. 

The modular \Rg{dsl} creation is discussed in \cite{1998_hudak_modular_dsl_and_tools}, \cite{2006_wyk_modular_dsl_extensions}. 
The language modularity, in a context of \jbmps\ is described in \cite{2012_ratiu_modular_dsls_and_analyses}, \cite{Voelter2011}.

The main focus of this work is a construction of the \cpppl\ on top of the \mbdr\ C implementation. Thus the modularity in the language engineering 
plays a key role in the work.

While extending the C language of the \mbdr\ with C++ specific \rgp{concept}, all the aspects of the language description (see previous subsection) have
to be extended. The newly introduced \rgp{concept} for nodes of the \rg{ast}, typical for C++, must inherit from some \rgp{concept} of the original 
\mbp\ C language. Not only new nodes and edges are introduced, but also constraints and other language description aspects have to be made incorporating the
newly introduced concepts. The practical side of the language modularity and extensibility is discussed throughout this work.

% TODO
%Quote more papers, bring an illustration

\subsection{Text Language Importers}
\label{importers}

When recreating an existing text language in projection, it is natural to support some libraries with it. The libraries, or a code 
base in another form, is present however not in the projectional form, but in the native for the language text code. Thus, for the 
user of the language, to be able to use the code base, it has to be \emph{imported} to the projectional editor. 

The import process consists of parsing the text code getting an \rg{ast} and converting the \rg{ast} in an \rg{ast}, as can
be described by the language in projection.

The task of import contains usually several principal challenges. At first, the native text language can have more 
constructions, than the version described in the projection. This happens, due to the intentions to omit some of them
in projection\footnote{dangerous constructions, like \cc{reinterpret\_cast}}, absence of them due to the simplicity of projectional 
implementation of the language, no need for them in projection, because the constructions are only specific to the textual nature of 
the code\footnote{for example, preprocessor directives}. Second, the projectional language can contain more information about the nodes,
than is present in the textual language, thus the information has to be generated or manually added later.

Additionally the technical work to create an importer can be considered significant, especially for complex languages, like the \cpppl.
