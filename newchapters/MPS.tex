\declsec{Jetbains MPS}{mps}

\jbmps\ stands for Jetbrains Meta Programming System. In this \Rg{ide}-like software it is possible to develop \Rgp{dsl}.
The approach taken in the \jbmps\ is rather unique, and it is considered to be advantageous in many ways, \cite{Voelter:MoDELS:2010}.

% No way to extend mbeddr otherwise
% Thus \jbmps\ is a good suitable technology for the practical implementation of the \MT\ goal.

In general, the way the language is describe in \jbmps\ coresponds to the way, described in the \rsec{modularlang}.
Here I will describe the process in practical details, as it is crucial for understanding the practical part of this \MT.

In this section I will go through a definition of one \rg{concept}, describing the facilities, \jbmps\ provides to support
it. Each \rg{concept} is described by several views on it. 

\msnozoom{mpsif}{\jbmps\ User Interface, \cc{if} Statement Concept}

Among such views there are \rg{concept} declaration (or language structure) view, editor view, behavior view, constraints view, type system view,
generator view and few more views. As a language consists mostly of the included in it concepts, 
the whole language is presented by the mentioned views as well, where each view on the language contains all views of the kind on each language \rg{concept}. 
Left part of the \fig{mpsif} demonstates the views on the \mpslang{statements} language.

The representation of a new language created in concepts and views to them, present a seamless approach to creating 
a new language with a projectional editor for it.

The \mbp\ is a software, separate from \jbmps\, but based on it, representing an extensible C language implementation with extensions.
I will use \rgp{concept} from the \mbp' throughout this section as examples to demonstrate MPS. Different C language parts are going to be 
decomposed into \rgp{concept} and these concepts are going to be defined using \jbmps. The reader should not confuse though the \mbp\ and 
\jbmps\ itself: the former is a software, developed in the latter and is used to demonstrate the latter.

\subsection{Concept Declaration}

\Rgp{concept}, as it is described in the \rsec{modularlang} represent a class-like types for nodes of an \rg{ast}. This terminology is kept in \jbmps\ and 
MPS concept has the same meaning as \rg{concept} term used in the \rsec{modularlang}. I use the term ``concept'' both in general, to describe an \rg{ast} node type,
and in particular referring to an MPS concept.

% Repeats \rsec{modularlang}
%
% One defines a language in it not through the canonical grammar approach, but instead through defining so called concepts, and relationships 
% between them similar to those in ER diagrams. A logical part of a language can be made a concept. 
% Related to C++, class, method declaration, field declaration can be represented as a concept. 

The \fig{mpsif} on the right part demonstrates a declaration of \mpsid{IfStatement} concept from the \mbdr\ \mpslang{statements} language.
It corresponds to the \cc{if} statement of the C language.

At first, the \rg{concept} is named, and the inheritance is defined. The \mpsid{IfStatment} \rg{concept} inherits from the \mpsid{Statement} \rg{concept}.
This allows the \mpsid{IfStatement} to be used at any place at which the \mpsid{Statement} could be used, and inherits like in object oriented programming
all data and behavior of the \mpsid{Statement}.

Next, it is defined, which interfaces the \rg{concept} is going to implement. For example, by implementing \mpsid{ISteppableContext}, the \mpsid{IfStatement}
supports the \mbdr\ debugger when stepping in the body of the \mpsid{IfStatement}.

The ``instance can be root'' property defines, if it is meaningful, to create a \rg{concept} without a parent \rg{concept} for it. In the case
of the \mpsid{IfStatment} it does not make sense, as the statement should belong to some block. The \cc{true} value can be used, e.g. for modules,
as they do not have any outer concepts, and can be seen as a document in \jbmps.

The ``properties'' part defines if the described \rg{concept} instances should have some primitive type data fields (string, boolean, int).
An example of a property could be a \mpsid{name} property of a variable declaration. The \mpsid{IfStatement} \rg{concept} does not specify any 
properties, neither does it inherit any from the \mpsid{Statement} concept.

The ``children'' section describe which nodes can be children on the \rg{ast} of the \mpsid{IfStatement}. Each child is assigned with a role and cardinality. 
For example, the \mpsid{IfStatement} should have exactly one child of \rg{concept} \mpsid{Expression}, it has a role ``condition''.

The ``references'' section describes in the similar way as in the ``children'' section, which nodes could be referenced by the node of a given \rg{concept}.
Referencing can be used, to bind a given node, to a node, located somewhere else on the \rg{ast}. As an example, a variable usage in expression shall reference
the variable declaration, to express precisely, which variable is used.

Finally, some attributes of a \rg{concept} follow, which do not have a primary importance for the discussion here. The ``alias'' is used to 
name a \rg{concept} in a short way, to allow for quick instantiation in the editor. The ``short description'' is shown to hint a programmer on the
alias meaning. A \rg{concept} can be made abstract in the ``concept properties'' section. Abstract \rgp{concept} are purely used in inheritance 
to create other non-abstract concepts with a common parent.

\subsection{Editor View}

The editor view is designed to give a look for a concept, and a way to input it. This is where the projection of an AST node is defined. As editors 
are mostly defined to look like text, a program in the \cpppl implemented in MPS looks almost like a regular C++ code.

\subsection{Behavior View}
The behavior view, can be used to define certain behavioral methods for a concept. A concept is represented there similar to a java class, and
it is possible to define the methods in a Java-like language.

\subsection{Constraints View}
The constraints view can be used, to limit in a desirable way relationships the concept can have to other concepts.

\subsection{Type System View}
The type system view is used mainly to define a type for each instance of a concept. The type is used later (for example, in the constraints), to 
determine suitability of the concept instance for a place, where it is used.

\subsection{Generator View}
The generator view, as well as the textgen view, is used to define the way, the concept instance is going to be transformed when generation of the AST
is invoked by the MPS user. In general, the generation is needed in the end of the programming, to obtain the source code from the AST in a textual representation.
This textual representation is needed because all existing tools (like compilers) expect text code nowadays. It is worth mentioning that, in theory, one
could implement a compiler, which works directly from the AST in the editor, eliminating thus the need in generators to text.

\subsection{Textgen View}

\subsection{Action View}

\subsection{Intentions}

\subsection{Other MPS Instruments}




