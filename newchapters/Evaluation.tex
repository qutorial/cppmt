\declchap{Evaluation}{eval}



\declsec{Comparison with Textual Approach}{comparison}

  It is important to compare the \rg{projectionalapproach} to build editors for languages to the well-adopted 
  textual approach. To the opinion of author the \rg{projectionalapproach} has a number of advantages, 
  which could make it more popular in the future, as well as, naturally, some disadvantages.
  
  First, in a projectional editor the programmer can potentially type less, as the editor is aware \emph{completely}
  about all the possible constructions, dislike various code-completing helpers in the textual editors, which can refuse 
  to work at all in some cases\footnote{when a program is in unparsable state, or when there is no source code for a library,
  sometimes, when a code base is to big to be indexed}. Thus the programmer may rely on the auto-completion much more, which
  can make the typing itself faster.

  Second, as an \rg{ast} is readily available  in a projectional editor, there is no need to pre-parse the code in order to 
  perform analysis on it to detect mistakes or for another purpose. In a textual editor before any analysis the program has to be 
  parsed first. Parsing is a computationally expensive operation. Repeating it after each time a piece of code is modified 
  puts a high load on the developer's machine and can slow it down significantly. 

  Third, in order to support refactoring an ultimate ``understanding'' of the code is required by the environment. 
  It is not always possible, however, especially this problem is well-known with complicated languages like the \cpppl.
  For example, one of the best C++ \rg{ide} Microsoft Visual C++, a problem of parsing complex C++ code and manipulating 
  on it is well-known, and parsers behind it are constantly updated, to support more of the C++.
    
  
  Fourth, is the flexibility to adopt new language constructions. 
  As a projectional editor allows for language modularity, \ref{modularity}, it is possible to extend a language, 
  without modifying an editor significantly, installing extensions for it or similar.
  
  Fifth, different naming conventions and coding standards can be replaced by decorations and the way a projectional editor
  projects the \rg{ast}. For example, a member variable, can be shown differently from a local variable in an method. This 
  eliminates the need in many of the coding conventions. Naming conventions are, however, usual to programmers, and their are
  implemented in a shape of analysis in the \pcpp, \ref{namingconventions}.

  Nowadays, in \jbmps\ the approach of generating a text code is taken, before the projected \rg{ast} could be further processed.
  However, taken into account the fact, that an \rg{ast} in a projectional editor represents the same, or even more, information 
  as an \rg{ast} resulting after parsing the text code generated, in future it is possible, to process the projected \rg{ast} itself,
  without generating a text code at all. For example, produce object code from it directly. Thus, in future, the compilation/processing
  of code from a projectional editor can be made much faster and effective when compared to the textual approach, where parsing takes place.
 
  A special problem with the projectional approach is moving the code around. As all nodes of the \rg{ast} get referenced by the use of their
  internal identifiers, and their names do not participate in it, after a piece of code has been moved to another location on the \rg{ast}, 
  a special processes of binding the nodes has to be executed. For example, if there was a variable \cc{x} in the code defined before the moved snippet,
  and in the new location for the snippet another variable with the same name \cc{x} is defined, the new \cc{x} will not get referenced by the 
  moved code snippet, as it references the old one (not available anymore) by its internal identifier. In \jbmps\ the manual process of rebinding is
  always required, i.e. the programmer will have to go over all nodes, which reference the old context, and input them again, to connect to the
  new context. In textual editors, there is no such problem, but another one exist - the moved code snippet can change its semantics in a wrong way
  after being associated with a new context, and not checked entirely. For example, a reference to a variable can start to reference some another, 
  locally defined, more close to the new code snippet location, variable with the same name as one, more global, used before. 
  
  Another very specific issue relevant to projectional editors is the format to store the projectional code and the version control for it.
  In \jbmps\ an \rg{ast} gets serialized as XML, and is stored in a file. The XML resulted, is, generally speaking, not a human-readable 
  code, despite the XML nature. The line-by line merging as employed in regular text-oriented version control systems (CVS, SVN, Git, Mercurial)
  does not apply, breaking the XML, or asking the user to merge, presenting with unreadable XML code. The approach taken in \jbmps\ is providing
  a special merge driver, which handles merging for the projectional code in a proper way. The driver is not perfect however, still requiring 
  the user to finish the job manually sometimes. 
  
  The new languages are developed themselves using a special defining projectional languages in \jbmps. So the evolution of a language under development,
  and its version control is also an issue. Each new incremental iteration of a language in \jbmps\ gets internally an increment in the language
  version number. When a second language is referencing the modified one, the version number is taken into account. The update for the first language
  then requires an update to the second, using the first,  language, as well as to all other languages, which use the updated one. If two updates happened
  at the same time for a language, then two \emph{different} versions with the same version number appear, which presents a problem for the 
  referencing the changed language languages. All this version control issues are still up to be thoroughly though of, and are not yet 
  implemented well enough.

  Additionally the question of language evolution and code in it is to be researched on.  When a language defined in a projectional editor is
  modified, the old code may turn to be not matching the language description anymore. For example, nodes may stop satisfying constraints,
  or have a child/reference with a role, deleted in the new language version, or, vice versa, have a nothing in a place where the new
  version language requires some child, reference or property. This renders the code in a former language version incorrect in a newer one.
  The question of the code update to a new language version appears. For example, a script can be provided with each new language version,
  which updates the code to the version in question. This is not automated however in \jbmps, so that the update process is seamless for the 
  language user. This is another problem to work on in the future. The problem described, of-course, is not relevant to the text code editors,
  as it is, since the language evolution there is rather untypical.

\declsec{Generalized Principles of the Projectional Approach}{genprinciples}

In this chapter I formulate some of the general principles, which can be taken into
account when designing new languages in the projectional editors, which are meant to represent, especially,
the existing already text languages. The principles come out as generalizations of the practical experience,
achieved during the work on this \MT.

\subsection{Targeting Semantics}

 When implementing a language for projectional editor, one should target semantics of it, rather than an existing syntax.
For example, extensions can be provided, which raise the abstraction level to be closer to the application of the language.
The code in the target text language is generated then from the higher level constructions. 

Another place to think of targeting semantics is, where the target language constructions are low-level and 
full of compiler-helping syntax. These constructions can be cleaned out, helping the programmer to focus on their
semantics, instead of typing and syntax.

\subsection{Store More Information}

 The language in the projectional editor can, and often should, contain \emph{more} information as it is needed 
 to just generate a text in the target language. This information may be used to improve the generation results, or
 analysis. Example is the overridden method link in the override in the \pcpp, \ref{overridefunction}.
 
 The disadvantage of this way can be a problem to extend the information, taken from an importer of the native text language,
 \ref{importers}.

\subsection{Configuration as a Part of Source Code}
 Usually a project consists not only of the source code, but of some configuration for it, like naming conventions, 
 generator configuration, build configuration, other specific to the project information.
 
 It presents advantageous to store this configuration together with code as a part of it. This eliminates the need 
 to separately configure an environment of each developer before the development process may start.

 Usually editor preferences are not shared among users, like in Eclipse for example, stored in a individual for each 
 machine workspace part. This brings a need to configure each development environment separately, and maintain the similarity
 of configuration.
 
 This should exclude, however, the pure developer-machine-specific configuration.

\subsection{Hide Redundant Syntax}

 Usually, textual languages contain a lot of syntax, which helps parsers of the language to process the code. 
 In C-like languages these are semicolons, curly braces, braces and brackets.
 
 This syntax has nothing to do usually with the code semantics, so it could be not projected at all, without changing
 the meaning of the code. Decreasing the amount of projected symbols the code can be made more readable.
 
 Formatting\footnote{it is important for some languages, like Python, and less relevant to C as syntax complication} can also be considered the redundant syntax, and addressed by projection.

\subsection{Make Old Syntax Readable}

  Whenever a syntax of the target language happened to be not well readable by itself, a projectional editor can 
  change it. The amount of punctuation can be lowered and some phenomena named in a human language.
  
  As an example I am bringing here a \rg{purevirtual} method declaration, \ref{purevirtualfuncs}.

\subsection{Show the Core, Hint on Details}

  Not necessarily all the information represents the core meaning of the language construction. The 
  most important information can be shown first, and the rest can be shown as a hint, especially when
  it can be figured out by the projectional editor automatically.
  
  As an example we can consider a friend function declaration in the \pcpp, \ref{accessandfriends}.

\subsection{Perform Analyses and Inform the User}
\label{analysisprinciple}

Performing various analyses on the \rg{ast} in the projectional editor, it is possible to improve the overall 
editing experience.

I suggest the logical division of analyses on two types: \rg{informativeanalysis} and \rg{preventiveanalysis}.

An \rg{informativeanalysis} can be performed to find out more about the edited code. Various newly found properties
can be shown as hints for the user. Abstract classes determination is an example of informative analysis, \ref{abstractclasses}. Another example
is class copying and assignment analysis, \ref{classcopying}.

A \rg{preventiveanalysis} can be performed to prevent programming mistakes. In general, this topic can go deep, and it is considered separately in, e.g.,
\cite{2012_ratiu_modular_dsls_and_analyses}. In this work as an example of such an analysis for C++ the detection of abstract class instantiation
attempts can serve, \ref{preventiveabstract}.

When implementing analysis, one should mind the complexity of it, and take the decision, whether to implement it as a \rg{selfrunninganalysis}, or
on as an \rg{analysisondemand}, see the \rsec{analysesandcomplexity}.

%%%%%%%%%%%%%%%%%%%%%%%%%

\declsec{Projectional Language Extensibility}{extensibility}

In general the extensibility and modularity are very important concepts for projectional editing, \ref{modularity}.

In \jbmps\ the extensibility consists of creating a new language and there some new \rgp{concept}, which represent an extension.
When creating \rgp{concept} in \jbmps\ one deals with several views of them, see \rsec{mps}. In this section I consider extensibility, and 
the most important, how well it is possible in \jbmps, per view on the language.

\subsection{Structure}

This view is the same as the view on \rg{concept} declarations.

Extensibility is implemented here by inheriting from the base \rg{concept}. It is rather straightforward, 
since it is very similar to the object oriented programming languages concept of inheritance, with one difference, 
actually originated from the Java notion of interface, as there is one base \rg{concept}, but several \rgp{interfaceconcept}
which could be implemented.

\subsection{Editor} 

It is hard to extend a language in terms of changing an editor concept (see \ref{mpseditor}) for an existing \rg{concept} in \jbmps.
Namely, there are no direct ways to perform inheritance there. 

So, if the way a \rg{concept} is edited or displayed has to be 
changed, one should take work around ways to achieve the needed behavior. 

One way is inheritance from the \rg{concept}, and changing the editor concept for the descendant.

Another way, is mixing some interface calls into the editor, and overriding the methods in the inheriting concept.
This way limits the editor to the way it was originally programmed is limited.

These both ways, however, do not change the way instances of the old \rg{concept} are presented.

In the new 3.0 version of \jbmps\ an ability to have several editors for one \rg{concept} is present. It is 
up to the future research, on how it will change the editor extensibility.

\subsection{Constraints}

Constraints, similar to the editor, does not extend well in \jbmps. Namely, there is no way to newly define the constraints
for an existing \rg{concept}. When creating a new concept, there is no way to reuse constraints from existing one, as they 
are not accessible.

As an example, when extending the \mbdr\ C to the \pcpp, the naming of identifiers had to be changed, so that C++ keywords
are accounted as well. They naming rules for identifiers are constrained in the \mpsid{IIdentifierNamedConcept} in \mbdr.
So in its constraints concept a limiting behavior is programmed. There is, however, no way to reuse it explicitly.

Another example would be the reference constraints, where a variable declaration would be forbidden to use an \rg{abstract} class
as a type. It is not possible to redefine those constraints, just adding a language, and not editing the existing one directly.

As a workaround two methods are proposed. First, the constraining behavior can be taken out into a separate code fragment in a Java-like class,
the abstract factory pattern could be implemented, \cite{GOF95}, and the polymorphic behavior achieved in this way.  Second, is to 
create a check, additionally constraining and marking as errors the places, where the new constraints have been violated.

The first workaround is work intensive to implement originally in the base language. The second workaround does not allow for extending the 
constraints, making them weaker, and lets the not allowed nodes in the code completion.


Additionally, it is noteworthy to mention, that it is possible to redefine a constraint for a certain role, when inheriting 
from a \rg{concept}.

In the future, a research could be made, how \jbmps\ could be improved to allow for easier constraints extensibility.

\subsection{Behavior}

Behavior is very similar to Java classes and their methods. It is easy to extend behavior of a \rg{concept} in \jbmps\
as all the object oriented methods for polymorphism can be involved in the very same way as for Java classes.

\subsection{TextGen}

\Rgp{textgen} are also very well extensible. When generating a text for a \rg{concept}, the children are output with 
the textgen \mpsid{append} command, without specifying, how exactly it should be done. Polymorphically the 
matching \rgp{textgen} are invoked, and this extends the \rg{textgen} of the previously defined \rg{concept}.

For example, when generating a text for a function, each statement of the body is generated to text. 
For each statement the \rg{textgen} of the statement itself is executed. Thus, if we add a new kind of statement,
all we need is to define a \rg{textgen} for it, and it will be polymorphically invoked from the \rg{textgen} for the
function. The text for the function will be generated correctly, without the need to change the function \rg{textgen}
implementation anyhow.

\subsection{Generators}

Generators perform language transformations in \jbmps, \ref{generators}. As this work does not directly 
implement language transformations, it is left for future research, to investigate, how extensible the 
generators are. 

\subsection{Intentions}

\Rgp{intention} are described in \ref{intentions}. 

There may be a need to modify an \rg{intention} after extending the language. There is no direct way to do it 
in \jbmps. 

For example, there is explicit way to forbid an \rg{intention} to work on a newly defined \rg{concept}, no matter
it is based on some \rg{concept} for which the \rg{intention} is defined.

As a workaround an injection of external polymorphic code from a Java-like class can be taken, similarly to the way it is 
described above for constraints, with the same practical outcome of a high programming intensity when creating the base language.

Alternatively, an \rg{intention} can delegate its function to the \rg{concept} under question, so that the whole manipulation is 
made by the target \rg{concept} itself. This will lead, however in a necessity to define a general behavior in the base concept, which can
be behaving wrong in one of the particular cases, or to the need to implement the polymorphic methods called in the \rg{intention} in 
\emph{each} of the descendant \rgp{concept}.

\subsection{Type System}

Type System in \jbmps\ is generally speaking another way of constraining. And exactly as in the situation with constraints 
there is no direct way to change the type system behavior, when extending an existing language with a new one. For example, 
when a new kind of expressions is added, which has to be typed differently, when used together with some existing expression type,
and the existing expression ty[e system is determining the type, it is not possible to redefine this behavior or extend in
naturally with some provided by \jbmps tools.

The workarounds consist from injecting polymorphic behavior in the type system calls, or from using \jbmps own workaround, like 
the replacement rule, as for example in \ref{pointertoclasstyping}.

Hopefully, in the future versions of \jbmps\ this is going to be taken care of, and some ways to extend naturally, by the 
means of the typing system itself will be present.

\subsection{Analyses}

Analyses are also subjects to challenge the language extensibility. If an analysis is relying on the exact \rgp{concept}
to work, and is not assuming that a new language could extend those, a problem happens.

For example, \mbdr\ data flow analysis, can analyse a C++ code snippet, using some class \cc{Circle}, to instantiate it \cc{Circle c;}
and produce an error, that the variable \cc{c} has not been initialized, which is not true in the case of a class with a constructor.
Either the analysis should delegate some features to \rg{concept}, or employ some external polymorphic calls as possible workarounds.
In the first case the analysis stops to be a separate programming from the language itself, as delegated analysis methods are found now
in the \rg{concept} behaviors. In the second case the development can get more complex initially, as the code should be written 
in the very beginning polymorphic and abstract enough to allow non-invasive modification in future.


Again, some specific support for analyses from \jbmps\ itself could improve the situation, by providing some special means 
to develop extensible analyses.


\subsection{Extensibility Overview}

Here I summarize in a table the degree of extensibility in \jbmps, provided for languages, per view on a language,
and the quality of known workarounds.

\begin{center}
\begin{tabular}{l|c|c}
\textbf{View} & \textbf{Extensibility} & \textbf{Workarounds Quality} \\
\hline
Structure & High & -\\
Editor & No & Poor\\
Constraints & Low & Good\\
Behavior & High & -\\
TextGen & High & -\\
Generators & - & -\\
Intentions & No & Medium\\
Type System & Low & Medium\\
Analyses & No & Medium
\end{tabular}
\end{center}


As an outcome it appears, that \jbmps\ does not provide a high degree of extensibility, which would allow 
a pure modular language engineering. The views, which are not extensibility aware could be improved, and the
task of improvement can be no trivial\footnote{the author implies does from the absence of good workarounds currently}.

\declsec{Analyses and Complexity}{analysesandcomplexity}

As it is stated before, \ref{analysisprinciple}, when constructing a language with an editor for it, 
it makes sense to provide the language with some analyses. Two types of analysis by application are considered:
\rg{informativeanalysis} and \rg{preventiveanalysis}. Two types of analysis by the way they are initiated are defined: 
\rg{selfrunninganalysis} and \rg{analysisondemand}.

A work flow of an analysis can be split into three major steps: initiation, running and reporting the result to the user.
On each of the steps the environment (\jbmps\ in this case) can provide certain support for the analysis, making the 
development of it easier. Below I discuss it step-by-step.

\subsection{Analysis Initiation}

It can be beneficial for the overall \rg{ide} performance to implement all computationally heavy analyses 
as \rgp{analysisondemand}. Thus the user invokes them when needed, and the question of initiation is solved.

For the \rgp{selfrunninganalysis} the question of automatic initiation is to be solved. In \jbmps\ there is no 
way to define, when a certain check is to be run. Thus two problems occur: some checks run too often, and 
decrease unnecessarily the system performance, or other checks do not happen often enough, and the user is not 
informed on time on the results\footnote{There is a way to re-run \rgp{selfrunninganalysis} in \jbmps\ manually,
by pressing F5}. 

As a solution to this an \rg{api} extension for can be proposed: for each analysis it should be possible 
to define an event, on which the analysis has to repeat, as well as which nodes of the \rg{ast} have to be covered.

For example, for the \rg{informativeanalysis} identifying \rg{abstract} classes, \ref{abstractclasses}, the running
event can be defined through the declaration of a new method or a new inheritance relationship established. The 
affected nodes of the \rg{ast} can be correspondingly described as the changed by the modification classes.

Thus the analysis will never run when changes made do not require it, and will always be run when 
it has to, and only on the affected nodes.


\subsection{Analysis Running}

After an analysis has been initiated, the running phase comes. Some analyses can be computationally complex,
as they can require external tools running, like SMT solvers, for example, \cite{2012_ratiu_modular_dsls_and_analyses},
or involve themselves complex algorithms.

As an example of a computationally intensive analysis, the \rg{preventiveanalysis} for \rg{abstract} classes 
instantiation can be taken, \ref{preventiveabstract}. At first, the amount of nodes of an \rg{ast} is high,
as they include local variable declarations, function parameters, function return types, class member variables
and more. Each of the nodes is checked like this: at first the type is extracted, then the type is checked to be 
a \mpsid{ClassType}. When an instance of the \mpsid{ClassType} is found, the \mpsid{Class} is checked on being abstract.
For this all of its method declarations are checked on being \rg{purevirtual}, and then all the base classes are 
checked on being abstract. If we take a reasonably big code base, like, for example the Qt library, which contains about one thousand
classes\footnote{989 classes in Qt 5.1}, the amount of nodes to check and the associated computations can be immense\footnote{If we assume,
that each class out of 1000 classes in a library has 1 parent, 3 member fields, 3 methods, each with 1 parameter, 1 return type, and 1 local variable,
we get up to 100 000 nodes to be addressed by the check.}.

As analyses can be started automatically, the computational load on an \rg{ide} can be increased as some analyses
may start in parallel. 

This all may present a performance problem, and a certain support from the \jbmps\ is needed to handle the task
of efficient analysis development.

First, as discussed in the previous subsection, it should be possible to control, when \rgp{selfrunninganalysis} start,
and the scope of their work. 

Second, some value caching is needed, to store the information figured out by the analyses. For example, for each
class, it could be saved, if it was found to be an \rg{abstract} class, and the cached value should be valid, until
the event to re-run the analysis is detected. It may be necessary, to retain the values after the \rg{ide} restart,

Third, as an analysis may take some time to execute, there has to be a way, to inform the user on the background process
running, so that the user interface is more clear about analyses and their run time. Currently, \jbmps\ does not inform
the user about it.

Fourth, there has to be a way to limit and prioritize the analyses running at the same time. For example, \rgp{preventiveanalysis}
can be preferred over \rgp{informativeanalysis}, and the total amount of analyses running in parallel could be limited 
to some number.



Fourth, as a change in one node may cause changes in other nodes, there has to be a


%TODO continue here

Take one analysis, research its complexity, figure out runtimes, MPS things

 Analysis can go on the syntax tree

 Which analysis can be needed in general
 
 The analysis can take time, online running complexity
 
 Naming conventions and regular expressions


 Analysis for abstract classes instantiation can happen very often, and is complex.
 
 
 
 RegExes for naming conventions - hard