\declchap{Evaluation}{eval}



\declsec{Comparison with Textual Approach}{comparison}

  It is important to compare the \rg{projectionalapproach} to build editors for languages to the well-adopted 
  textual approach. To the opinion of author the \rg{projectionalapproach} has a number of advantages, 
  which could make it more popular in the future, as well as, naturally, some disadvantages.
  
  First, in a projectional editor the programmer can potentially type less, as the editor is aware \emph{completely}
  about all the possible constructions, dislike various code-completing helpers in the textual editors, which can refuse 
  to work at all in some cases\footnote{when a program is in unparsable state, or when there is no source code for a library,
  sometimes, when a code base is to big to be indexed}. Thus the programmer may rely on the auto-completion much more, which
  can make the typing itself faster.

  Second, as an \rg{ast} is readily available  in a projectional editor, there is no need to pre-parse the code in order to 
  perform analysis on it to detect mistakes or for another purpose. In a textual editor before any analysis the program has to be 
  parsed first. Parsing is a computationally expensive operation. Repeating it after each time a piece of code is modified 
  puts a high load on the developer's machine and can slow it down significantly. 

  Third, in order to support refactoring an ultimate ``understanding'' of the code is required by the environment. 
  It is not always possible, however, especially this problem is well-known with complicated languages like the \cpppl.
  For example, one of the best C++ \rg{ide} Microsoft Visual C++, a problem of parsing complex C++ code and manipulating 
  on it is well-known, and parsers behind it are constantly updated, to support more of the C++.
    
  
  Fourth, is the flexibility to adopt new language constructions. 
  As a projectional editor allows for language modularity, \ref{modularity}, it is possible to extend a language, 
  without modifying an editor significantly, installing extensions for it or similar.
  
  Fifth, different naming conventions and coding standards can be replaced by decorations and the way a projectional editor
  projects the \rg{ast}. For example, a member variable, can be shown differently from a local variable in an method. This 
  eliminates the need in many of the coding conventions. Naming conventions are, however, usual to programmers, and their are
  implemented in a shape of analysis in the \pcpp, \ref{namingconventions}.

  Nowadays, in \jbmps\ the approach of generating a text code is taken, before the projected \rg{ast} could be further processed.
  However, taken into account the fact, that an \rg{ast} in a projectional editor represents the same, or even more, information 
  as an \rg{ast} resulting after parsing the text code generated, in future it is possible, to process the projected \rg{ast} itself,
  without generating a text code at all. For example, produce object code from it directly. Thus, in future, the compilation/processing
  of code from a projectional editor can be made much faster and effective when compared to the textual approach, where parsing takes place.
 
  A special problem with the projectional approach is moving the code around. As all nodes of the \rg{ast} get referenced by the use of their
  internal identifiers, and their names do not participate in it, after a piece of code has been moved to another location on the \rg{ast}, 
  a special processes of binding the nodes has to be executed. For example, if there was a variable \cc{x} in the code defined before the moved snippet,
  and in the new location for the snippet another variable with the same name \cc{x} is defined, the new \cc{x} will not get referenced by the 
  moved code snippet, as it references the old one (not available anymore) by its internal identifier. In \jbmps\ the manual process of rebinding is
  always required, i.e. the programmer will have to go over all nodes, which reference the old context, and input them again, to connect to the
  new context. In textual editors, there is no such problem, but another one exist - the moved code snippet can change its semantics in a wrong way
  after being associated with a new context, and not checked entirely. For example, a reference to a variable can start to reference some another, 
  locally defined, more close to the new code snippet location, variable with the same name as one, more global, used before. 
  
  Another very specific issue relevant to projectional editors is the format to store the projectional code and the version control for it.
  In \jbmps\ an \rg{ast} gets serialized as XML, and is stored in a file. The XML resulted, is, generally speaking, not a human-readable 
  code, despite the XML nature. The line-by line merging as employed in regular text-oriented version control systems (CVS, SVN, Git, Mercurial)
  does not apply, breaking the XML, or asking the user to merge, presenting with unreadable XML code. The approach taken in \jbmps\ is providing
  a special merge driver, which handles merging for the projectional code in a proper way. The driver is not perfect however, still requiring 
  the user to finish the job manually sometimes. 
  
  The new languages are developed themselves using a special defining projectional languages in \jbmps. So the evolution of a language under development,
  and its version control is also an issue. Each new incremental iteration of a language in \jbmps\ gets internally an increment in the language
  version number. When a second language is referencing the modified one, the version number is taken into account. The update for the first language
  then requires an update to the second, using the first,  language, as well as to all other languages, which use the updated one. If two updates happened
  at the same time for a language, then two \emph{different} versions with the same version number appear, which presents a problem for the 
  referencing the changed language languages. All this version control issues are still up to be thoroughly though of, and are not yet 
  implemented well enough.

  Additionally the question of language evolution and code in it is to be researched on.  When a language defined in a projectional editor is
  modified, the old code may turn to be not matching the language description anymore. For example, nodes may stop satisfying constraints,
  or have a child/reference with a role, deleted in the new language version, or, vice versa, have a nothing in a place where the new
  version language requires some child, reference or property. This renders the code in a former language version incorrect in a newer one.
  The question of the code update to a new language version appears. For example, a script can be provided with each new language version,
  which updates the code to the version in question. This is not automated however in \jbmps, so that the update process is seamless for the 
  language user. This is another problem to work on in the future. The problem described, of-course, is not relevant to the text code editors,
  as it is, since the language evolution there is rather untypical.

\declsec{Generalized Principles of the Projectional Approach}{genprinciples}

In this chapter I formulate some of the general principles, which can be taken into
account when designing new languages in the projectional editors, which are meant to represent, especially,
the existing already text languages. The principles come out as generalizations of the practical experience,
achieved during the work on this \MT.

\subsection{Targeting Semantics}

 When implementing a language for projectional editor, one should target semantics of it, rather than an existing syntax.
For example, extensions can be provided, which raise the abstraction level to be closer to the application of the language.
The code in the target text language is generated then from the higher level constructions. 

Another place to think of targeting semantics is, where the target language constructions are low-level and 
full of compiler-helping syntax. These constructions can be cleaned out, helping the programmer to focus on their
semantics, instead of typing and syntax.

\subsection{Store More Information}

 The language in the projectional editor can, and often should, contain \emph{more} information as it is needed 
 to just generate a text in the target language. This information may be used to improve the generation results, or
 analysis. Example is the overridden method link in the override in the \pcpp, \ref{overridefunction}.
 
 The disadvantage of this way can be a problem to extend the information, taken from an importer of the native text language,
 \ref{importers}.

\subsection{Configuration as a Part of Source Code}
 Usually a project consists not only of the source code, but of some configuration for it, like naming conventions, 
 generator configuration, build configuration, other specific to the project information.
 
 It presents advantageous to store this configuration together with code as a part of it. This eliminates the need 
 to separately configure an environment of each developer before the development process may start.

 Usually editor preferences are not shared among users, like in Eclipse for example, stored in a individual for each 
 machine workspace part. This brings a need to configure each development environment separately, and maintain the similarity
 of configuration.
 
 This should exclude, however, the pure developer-machine-specific configuration.

\subsection{Hide Redundant Syntax}

 Usually, textual languages contain a lot of syntax, which helps parsers of the language to process the code. 
 In C-like languages these are semicolons, curly braces, braces and brackets.
 
 This syntax has nothing to do usually with the code semantics, so it could be not projected at all, without changing
 the meaning of the code. Decreasing the amount of projected symbols the code can be made more readable.
 
 Formatting\footnote{it is important for some languages, like Python, and less relevant to C as syntax complication} can also be considered the redundant syntax, and addressed by projection.

\subsection{Make Old Syntax Readable}

  Whenever a syntax of the target language happened to be not well readable by itself, a projectional editor can 
  change it. The amount of punctuation can be lowered and some phenomena named in a human language.
  
  As an example I am bringing here a \rg{purevirtual} method declaration, \ref{purevirtualfuncs}.

\subsection{Show the Core, Hint on Details}

  Not necessarily all the information represents the core meaning of the language construction. The 
  most important information can be shown first, and the rest can be shown as a hint, especially when
  it can be figured out by the projectional editor automatically.
  
  As an example we can consider a friend function declaration in the \pcpp, \ref{accessandfriends}.

\subsection{Perform Analyses and Inform the User}

Performing various analyses on the \rg{ast} in the projectional editor, it is possible to improve the overall 
editing experience.

I suggest the logical division of analyses on two types: informative and preventive.

An informative analysis can be performed to find out more about the edited code. Various newly found properties
can be shown as hints for the user. Abstract classes determination is an example of informative analysis, \ref{abstractclasses}. Another example
is class copying and assignment analysis, \ref{classcopying}.

A preventive can be performed to prevent programming mistakes. In general, this topic can go deep, and it is considered separately in, e.g.,
\cite{2012_ratiu_modular_dsls_and_analyses}. In this work as an example of such an analysis for C++ the detection of abstract class instantiation
attempts can serve, \ref{preventiveabstract}.

When implementing analysis, one should mind the complexity of it, and take the decision, whether to implement it as a \rg{selfrunninganalysis}, or
on as an \rg{analysisondemand}, see the \rsec{analysesandcomplexity}.

%%%%%%%%%%%%%%%%%%%%%%%%%

\declsec{Projectional Language Extensibility}{extensibility}

Extensibility of different languages to create a concept is discussed here.


\subsection{Structure}
Inheritance like (but confusion with base concept and inmplements)

\subsection{Editor} 
One only, can't be changed, in MPS3.0 - better, but how much? - future work

\subsection{Constraints}

No way to change nicely, but possible (IIdentifier Named concept, Cpp reserved words, get problem (to do: find about it Markus's letter) )
Also constrain LocVar decl to not allow abstract classes - not possible, have to use check.

\subsection{Behavior}

Nice, like Java

\subsection{TextGen}

Nice, as it supports polymorhism.

\subsection{Generators}
- not related ?
may be hard to extend... because in general hard...

\subsection{Actions and Intentions}
- not needed ? Or? How to forbid an intention on something?


\subsection{Type System}
- pain! Replacement rule mentined here
%TODO Talk about the replacement rule
Similar to constraints actually.


\subsection{Extensibility Overview}
Summary in a shape of a table

%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Current State and Future Work}
And finally, some ways to come over, and how MPS can be made better later.


\declsec{Analyses and Complexity}{analysesandcomplexity}

Take one analysis, analyze complexity, figure out runtimes, MPS things

 Analysis can go on the syntax tree

 Which analysis can be needed in general
 
 The analysis can take time, online running complexity
 
 Naming conventions and regular expressions


 Analysis for abstract classes instantiation can happen very often, and is complex.
 
 
 
 RegExes for naming conventions - hard