\chapter{Generalized Principles of the Projectional Approach}
\lchap{genprinciples}

In this chapter I formulate some of the general principles, which can be taken into
account when designing new languages in the projectional editors.

\section{Targeting Semantics}
%No matter what you generate to, you should target semantics - way to cover the abstraction gap

\section{Store More Information}
% More information can and SHOULD be stored than is needed for generation.
% Example is the overridden method link in the override

% Disadvantage - native code compatibility

\section{Configuration as a Part of Source Code}
% Configuration (as naming conventions) is nice to store with code! 
% Usually editor preferences are not shared like in eclipse, but this can enforce standards
% Another example would be the build configuration indeed.

\section{Hide Redundant Syntax}
% Don't show to the programmer semicolons and similar.

%TODO More?


\chapter{Analysis and Complexity}
\lchap{analysisandcomplexity}

% Analysis can go on the syntax tree
% Which analysis can be needed in general
% The analysis can take time, online running complexity
% Naming conventions and regular expressions


\chapter{Comparison with Textual Approach}
\lchap{comparison}

% Compare work with textual editor
% Compare the way analysis is performed
% Compare the naturality for the programmer
% Compare flexibility
% About direct compilation without generating text code
% Amount of typing and code generation
% Extensibility and higher level construction
% Moving code around is easy locally, but difficult from module to module
% Compare the version control Language And Code itself - different
% Refactorings require cool parser and are not implemented VS2010 new parser adoption
% Compare naming conventions