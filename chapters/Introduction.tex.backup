\chapter{Introduction}
\label{chapter:Introduction}

Here I introduce the main concepts and existing work, relevant to this \MT.

 
\section{Projectional Editing}
Traditionally programming languages are used in a textual form in text files, forming programs.
However the textual nature is not typical for the structure of programs themselves, being rather low-level
representation of code. Parsers are used to construct so called abstract syntax trees (ASTs) from the textual 
program representation. ASTs are structures in memory, usually graph-alike, reminding sometimes control flow
graph, where nodes are different statements and edges are the ways control passes from one statement to the 
next one.

For the developer, using an editor, the degree to which the editor can support the development process is 
important. For this, the editor has to recognize the programming language construction and provide possible assistance.
Among such assistance can be code formatting, syntax validation, source code transformations (including refactoring support), code analyses and verification, 
source code generation and others. Many of these operation rely indeed on the higher than text level notions related to program such as method,
variable, statement. A good editor has to be aware of these higher level program structure.

Nowadays most of the editors work with text, and to provide assistance to programmer integrate with parser/compiler front-end 
for the programming language. This way to extract the program structure during editing is not perfect for several reasons.
First of all, the program being edited as text is not syntactically correct at every moment, being incomplete, for 
example. Under this circumstances the parsing front-end can not be successfully invoked and returns error messages
which are usually false-positive. Secondly, after minor editing of the code, usually the whole text file has to be
processed again. Such compiler calls are usually computationally expensive, they slow down, sometimes significantly, 
the performance of the developer machine. Various techniques exist to speed it up, including partial and pre- compilation,
but the problem is still relevant to large extent. 

Moreover, the textual nature of the code complicates certain operations additionally. As an example, we can take a refactoring
to rename a method. Every usage of the method, being renamed, has to be found and changed. To implement it correctly an editor
must take into account various possible name collisions, as well as presume a compilable state of the program to even start
the refactoring.




 


