\chapter{C and C++}
\label{chapter:CAndCpp}

Initially C++ appeared to be an extesnion to the C language, called ``C with Classes'' \cite{cwithclasses}. Till now the high degree
of commonality can be found between the two languages. Mainly, the most of the C code is going to be valid C++ code. 

\section{Reference Type and Boolean Type}

Among primitive types and operations there are two major differences relevant to practice.
They are discussed in the following subsections.

\subsection{Reference Type}

Reference type is basically a new construct in C++ which represent the old notion of pointer in C with a different syntax.
The syntax for a variable of type \cc{T} can be used with the variable of type reference to \cc{T}, or \cc{\&T} as it is designated in C++.
It comes especially handy when passing arguments to methods by reference, which avoids creating a copy of an object to pass 
by value.
\cpp{Reference Type in a Copy Constructor}{copyconstructor}

The value of the reference type in C++ is bigger however, than just a new syntax for pointers. A constant reference to a class object 
has to be used in constructor to give it a special meaning of a copy constructor, as the \rl{copyconstructor} demonstrates.


\subsection{Boolean Type}

% Need in C++
The \cpppl\ has a special \cc{bool} type to represent the two logical values. There is no such type in C.

%Implementation
No matter, the \cc{bool} type is not present in C, for the convenience of the user the \mb\ C implementation introduced a type \cc{bool},
which is translated to \cc{int8\_t}, together with \cc{true} and \cc{false} values, converting to \cc{1} and \cc{0} respectively.
This implementation can be considered better than the original C++ \cc{bool} type present in the generated code, because the \cpppl\ standard
does not define explicitly the size of the \cc{bool} type \cite{cpp11}.

In the context of embedded systems, which we target, see \ref{g1}, it is often very important to 
know precisely, with which type the user is operating, as the limited resources
are important to consider. Substituting the \cc{bool} type with the \cc{int8\_t} type ensures that the size of the \cc{bool} variables is known.
Also, it can be changed as needed in the \cc{TypeSizeConfiguration} in each model created with \mb\ separately.

The C++ standard explicitly allows the \cc{bool} type to participate in integer promotions. This ensures further the compatibility of the custom-written
text code, which may use actual \cc{bool} type, with the code generated with substitution of \cc{bool} to \cc{int8\_t}, as the user \cc{bool} will be promoted.

%Limitations
Among limitations of this approach one can take as an example \cc{std::vectoor<bool>}. Since the word ``bool'' itself is never generated, 
it is not possible to use the specialization of template, which ensures storage optimization, through, though, higher processing load when
extracting a value from such vector.

\section{Modules}


\section{Memory Allocation}

%TODO Write about new and delete for arrays



%In C++
%Implicit Assignment from void*
%Freeing arrays: new[] and delete[]
%declare functions before use


%TODO : Exceptions!

%LOL http://stackoverflow.com/questions/3027177/what-are-the-differences-between-c-and-c
%Quote:
%In terms of power:
% - C is a chainsaw.
% - C++ is a 50-foot tall earthmover that mows down everything in its path, and has giant chainsaws sticking out of its wheel hubs to boot.
%Sure, both can clear trees out of your way, but...
%
%In terms of special:
%
% - C is a rockstar.
% - C++ is a narco-syndicate collective of superheroes.



% Let's go back to somewhat less ``intuitive'' comparisons...



%     \begin{enumerate}
%       \item Differences between C and C++
% 	\begin{enumerate}
% 	 \item Reference Type and Boolean Type
% 	 \item Modules Support
% 	 \item Object Oriented Approach Support
% 	\end{enumerate}
%     \end{enumerate}


% Need in C++
% Challenge to implement
% MPS support
% Comprosises - trade of's
